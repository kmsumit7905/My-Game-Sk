<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Dodger — Pro Edition</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600;800&family=Poppins:wght@600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#07101a;
    --panel: rgba(255,255,255,0.03);
    --neon1:#00f0ff;
    --neon2:#ff2ec8;
    --accent:#7cff6b;
    --glass: rgba(255,255,255,0.04);
  }
  *{box-sizing:border-box;margin:0;padding:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  html,body{height:100%;background:
    radial-gradient(800px 400px at 10% 10%, rgba(0,240,255,0.03), transparent),
    radial-gradient(700px 300px at 90% 90%, rgba(255,46,200,0.02), transparent),
    var(--bg); color:#dfeeff; -webkit-font-smoothing:antialiased;}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:32px;}
  .ui{width:980px;max-width:98vw;display:grid;grid-template-columns:1fr 360px;gap:22px;align-items:start;}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.006));border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 12px 40px rgba(2,6,23,0.6);position:relative;overflow:hidden;}
  .title{display:flex;gap:12px;align-items:center;margin-bottom:12px}
  .logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--neon1),var(--neon2));display:flex;align-items:center;justify-content:center;font-weight:800;color:#041019;box-shadow:0 8px 30px rgba(0,240,255,0.06)}
  h1{font-size:18px;margin:0}
  .desc{color:rgba(200,220,255,0.62);font-size:13px}
  .canvas-wrap{height:640px;border-radius:12px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002)); border:1px solid rgba(255,255,255,0.03);position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden;}
  canvas{display:block;border-radius:10px;background:linear-gradient(180deg, rgba(10,14,20,0.5), rgba(0,0,0,0.2));box-shadow:inset 0 8px 40px rgba(0,0,0,0.6);}
  .hud{position:absolute;left:18px;top:18px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:8px 14px;border-radius:999px;font-weight:700;color:#bff7ff;border:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(6px)}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;backdrop-filter: blur(6px);transition:opacity .22s}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.008));padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);text-align:center;max-width:360px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .card h2{margin:0 0 8px;font-family:Poppins,Inter;font-weight:700}
  .btn{background:linear-gradient(90deg,var(--neon1),var(--neon2));color:#041018;padding:10px 14px;border-radius:10px;font-weight:800;border:none;cursor:pointer;box-shadow:0 8px 30px rgba(0,240,255,0.06)}
  .controls{display:flex;flex-direction:column;gap:10px;margin-top:8px}
  .stat{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);display:flex;justify-content:space-between;align-items:center}
  .stat strong{font-size:18px}
  .small{font-size:13px;color:rgba(210,230,255,0.7)}
  .info .row{display:flex;gap:8px}
  .info .secondary{background:transparent;border:1px dashed rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:#9fb3ff;cursor:pointer}
  /* mobile controls */
  .touch-controls{position:absolute;left:50%;transform:translateX(-50%);bottom:10px;display:flex;gap:18px;align-items:center;z-index:40}
  .tc-btn{width:76px;height:56px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.008));border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-weight:700;color:#dff;box-shadow:0 6px 20px rgba(0,0,0,0.6);user-select:none}
  .fs-btn{position:absolute;right:18px;top:18px;background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:#9fb3ff;cursor:pointer}
  /* neon hit flash */
  .flash{position:absolute;inset:0;background:radial-gradient(circle at var(--x,50%) var(--y,50%), rgba(255,255,255,0.06), transparent 18%);pointer-events:none;opacity:0;transition:opacity .18s}
  @media (max-width:920px){ .ui{grid-template-columns:1fr; } .canvas-wrap{height:56vh} .info{order:2} .panel{padding:12px} }
</style>
</head>
<body>
<div class="wrap">
  <div class="ui">
    <div class="panel">
      <div class="title">
        <div class="logo">ND</div>
        <div>
          <h1>Neon Dodger — Pro</h1>
          <div class="desc">Sleek, responsive and tactile. Use ← → or touch. Survive as long as you can.</div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <div class="hud" id="hud">Score: 0</div>
        <button class="fs-btn" id="fsBtn" title="Fullscreen">⤢</button>
        <canvas id="game" width="900" height="660"></canvas>

        <div id="overlay" class="overlay">
          <div class="card">
            <h2>Neon Dodger</h2>
            <p class="small">Tap to start. Smooth neon visuals, subtle particles, polished UX.</p>
            <div style="height:12px"></div>
            <button id="startBtn" class="btn">Start</button>
            <div style="height:10px"></div>
            <div class="small">High Score: <strong id="high">0</strong></div>
          </div>
        </div>

        <div id="touchControls" class="touch-controls" aria-hidden="true" style="display:none">
          <div id="leftBtn" class="tc-btn">◀</div>
          <div id="rightBtn" class="tc-btn">▶</div>
        </div>

        <div id="flash" class="flash"></div>
      </div>
      <div style="height:8px"></div>
      <div class="small" style="text-align:center">Made with canvas — local high score saved</div>
    </div>

    <div class="panel info">
      <div class="stat"><span class="small">Score</span><strong id="score">0</strong></div>
      <div class="stat"><span class="small">High</span><strong id="best">0</strong></div>
      <div class="stat"><span class="small">Speed</span><strong id="speed">1x</strong></div>

      <div class="controls">
        <div class="row">
          <button id="pauseBtn" class="secondary info-btn">Pause</button>
          <button id="restartBtn" class="secondary info-btn">Restart</button>
        </div>
        <div class="small">Controls: Arrow keys, A/D or touch. Toggle fullscreen for immersive play.</div>
        <div style="height:8px"></div>
        <div class="row">
          <button id="themeBtn" class="secondary info-btn">Toggle Color</button>
          <button id="soundBtn" class="secondary info-btn">Sound: On</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const themeBtn = document.getElementById('themeBtn');
  const soundBtn = document.getElementById('soundBtn');
  const fsBtn = document.getElementById('fsBtn');
  const hud = document.getElementById('hud');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const highEl = document.getElementById('high');
  const speedEl = document.getElementById('speed');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const touchControls = document.getElementById('touchControls');
  const flash = document.getElementById('flash');

  // HiDPI support
  function setCanvasSize(w,h){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // responsive initial size
  function calcSize(){
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();
    const targetW = Math.min(900, Math.max(340, rect.width - 24));
    const ratio = 900/660;
    const targetH = Math.round(targetW / ratio);
    setCanvasSize(targetW, targetH);
    W = canvas.width / (window.devicePixelRatio || 1);
    H = canvas.height / (window.devicePixelRatio || 1);
    player.y = H - 70;
  }
  window.addEventListener('resize', calcSize);

  // game state
  let W = 900, H = 660;
  let running = false, paused = false, raf = 0;
  let score = 0, best = parseInt(localStorage.getItem('nd_best')||0,10);
  let colorScheme = 0;
  let speedMultiplier = 1;
  bestEl.textContent = best;
  highEl.textContent = best;

  // player with smooth movement
  const player = {
    x: W/2,
    targetX: W/2,
    y: H - 70,
    w:56,
    h:14,
    speed: 650, // px/sec maximum
    vx:0,
    color:'#7cff6b',
    friction: 0.12
  };

  // obstacles and particles
  let obstacles = [];
  let spawnTimer = 0, spawnRate = 60;
  let frame = 0;
  let particles = [];

  // input
  const keys = {};
  window.addEventListener('keydown', e => { keys[e.key] = true; if(['ArrowLeft','ArrowRight','a','d','A','D'].includes(e.key)) e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  // touch virtual buttons
  let touchLeft = false, touchRight = false;
  leftBtn.addEventListener('pointerdown', ()=> touchLeft = true);
  leftBtn.addEventListener('pointerup', ()=> touchLeft = false);
  leftBtn.addEventListener('pointerleave', ()=> touchLeft = false);
  rightBtn.addEventListener('pointerdown', ()=> touchRight = true);
  rightBtn.addEventListener('pointerup', ()=> touchRight = false);
  rightBtn.addEventListener('pointerleave', ()=> touchRight = false);

  // pointer drag for direct control
  let dragging = false;
  canvas.addEventListener('pointerdown', e => {
    dragging = true;
    const r = canvas.getBoundingClientRect();
    player.targetX = e.clientX - r.left;
  });
  window.addEventListener('pointermove', e => {
    if (!dragging) return;
    const r = canvas.getBoundingClientRect();
    player.targetX = e.clientX - r.left;
  });
  window.addEventListener('pointerup', ()=> dragging = false);

  // utility
  function rnd(min,max){ return Math.random()*(max-min)+min; }

  // spawn
  function spawnObstacle(){
    const w = Math.round(rnd(36, 110) * (1 + 0.015*score));
    const x = rnd(12, W - w - 12);
    const speed = rnd(120, 260) * (1 + score*0.006) * speedMultiplier; // px/sec
    const hue = colorScheme===0 ? 190 + Math.random()*60 : 300 + Math.random()*40;
    obstacles.push({x, y:-20 - rnd(0,80), w, h:16, speed, hue});
  }

  // particles for movement / hit
  function spawnParticle(x,y,dx,dy,color,life=480){
    particles.push({x,y,dx,dy,color,life,age:0});
  }

  // reset
  function reset(){
    obstacles = []; particles = []; score = 0; spawnTimer = 0; spawnRate = 60; speedMultiplier = 1;
    player.x = W/2; player.targetX = W/2; player.vx = 0;
    hud.textContent = 'Score: 0';
    scoreEl.textContent = '0';
    speedEl.textContent = '1x';
  }

  // start / end
  function start(){
    overlay.style.opacity = 0; overlay.style.pointerEvents = 'none';
    running = true; paused = false; reset(); loop();
    // show mobile controls if narrow
    if (window.innerWidth < 720) touchControls.style.display = 'flex';
  }

  function endGame(){
    running = false; cancelAnimationFrame(raf);
    overlay.style.pointerEvents = 'all'; overlay.style.opacity = 1;
    document.querySelector('#overlay .card h2').textContent = 'Game Over';
    // flash
    flash.style.setProperty('--x', (player.x / W * 100) + '%');
    flash.style.setProperty('--y', (player.y / H * 100) + '%');
    flash.style.opacity = 1; setTimeout(()=> flash.style.opacity = 0, 160);
    // score update
    if (score > best){ best = score; localStorage.setItem('nd_best', best); bestEl.textContent = best; highEl.textContent = best; }
    startBtn.textContent = 'Play Again';
  }

  function togglePause(){
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if (!paused) loop();
  }

  // collision helper
  function aabb(px,py,pw,ph, ox,oy,ow,oh){
    return (px < ox+ow && px+pw > ox && py < oy+oh && py+ph > oy);
  }

  // main update (time-based)
  let lastT = 0;
  function update(t){
    if (!running || paused) { lastT = t; return; }
    const dt = Math.min(40, t - lastT) / 1000; // max step clamp
    lastT = t;
    frame++;

    // handle input target
    let inputDir = 0;
    if (keys['ArrowLeft']||keys['a']||keys['A']||touchLeft) inputDir -= 1;
    if (keys['ArrowRight']||keys['d']||keys['D']||touchRight) inputDir += 1;

    // if arrow held, move target relative; otherwise target set by dragging / pointer
    if (inputDir !== 0){
      player.targetX += inputDir * player.speed * 0.9 * dt;
    }

    // lerp vx toward target
    const desired = Math.max(player.w/2 + 8, Math.min(W - player.w/2 - 8, player.targetX));
    const diff = desired - player.x;
    // soft acceleration: velocity proportional to difference, capped
    player.vx += diff * 12 * dt;
    // friction damp
    player.vx *= (1 - Math.min(0.9, player.friction));
    // clamp
    const maxv = player.speed * (1 + score*0.002) * speedMultiplier * dt;
    player.x += Math.max(-maxv, Math.min(maxv, player.vx));

    // spawn logic (time-based)
    spawnTimer++;
    if (spawnTimer >= Math.max(12, spawnRate - Math.floor(score/6))){
      spawnTimer = 0; spawnObstacle();
    }

    // update obstacles (px/sec converted using dt)
    for (let i = obstacles.length-1; i >= 0; i--){
      const ob = obstacles[i];
      ob.y += ob.speed * dt;
      // collision
      const px = player.x - player.w/2, pw = player.w, py = player.y - player.h/2, ph = player.h;
      if (aabb(px,py,pw,ph, ob.x, ob.y, ob.w, ob.h)){
        // spawn hit particles
        for (let p=0; p<24; p++){
          spawnParticle(player.x + rnd(-8,8), player.y + rnd(-8,8), rnd(-160,160), rnd(-120,160), `hsla(${ob.hue},100%,60%,0.95)`, 900);
        }
        playHit();
        endGame();
        return;
      }
      if (ob.y > H + 60){
        obstacles.splice(i,1);
        score += 1;
        hud.textContent = 'Score: ' + score;
        scoreEl.textContent = score;
        if (score % 8 === 0) speedMultiplier += 0.06;
        speedEl.textContent = speedMultiplier.toFixed(2) + 'x';
      }
    }

    // update particles
    for (let i = particles.length-1; i>=0; i--){
      const p = particles[i];
      p.x += p.dx * dt;
      p.y += p.dy * dt;
      p.age += dt * 1000;
      p.dx *= 0.99; p.dy *= 0.99;
      if (p.age > p.life) particles.splice(i,1);
    }
  }

  // simple neon drawing helpers
  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function draw(){
    // clear
    ctx.clearRect(0,0,W,H);

    // subtle vignette
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'rgba(255,255,255,0.01)'); g.addColorStop(1,'rgba(0,0,0,0.06)');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // grid background faint lines
    ctx.save(); ctx.globalAlpha = 0.06; ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
    for (let x=0; x<W; x+=42){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for (let y=0; y<H; y+=42){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.restore();

    // obstacles neon with glow
    obstacles.forEach(ob=>{
      const grad = ctx.createLinearGradient(ob.x, ob.y, ob.x+ob.w, ob.y+ob.h);
      grad.addColorStop(0, `hsla(${ob.hue},100%,62%,0.96)`); grad.addColorStop(1, `hsla(${(ob.hue+40)%360},100%,50%,0.9)`);
      ctx.fillStyle = grad;
      ctx.shadowColor = `hsla(${ob.hue},100%,60%,0.18)`; ctx.shadowBlur = 20;
      roundRect(ctx, ob.x, ob.y, ob.w, ob.h, 8); ctx.fill();
      ctx.shadowBlur = 0;
      // inner sheen
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(ob.x + 6, ob.y + 2, ob.w - 12, 4);
    });

    // player neon rounded bar with subtle glow
    ctx.save();
    const px = player.x - player.w/2, py = player.y - player.h/2;
    const pgrad = ctx.createLinearGradient(px, py, px + player.w, py + player.h);
    if (colorScheme===0){ pgrad.addColorStop(0,'#7cff6b'); pgrad.addColorStop(1,'#00f0ff'); }
    else { pgrad.addColorStop(0,'#ff8ae0'); pgrad.addColorStop(1,'#ffdf5b'); }
    ctx.fillStyle = pgrad;
    ctx.shadowColor = 'rgba(0,255,255,0.16)'; ctx.shadowBlur = 26;
    roundRect(ctx, px, py, player.w, player.h, 8); ctx.fill();
    ctx.restore();

    // player movement trail particles
    for (let i = 0; i < 3; i++){
      spawnParticle(player.x + rnd(-6,6), player.y + player.h/2 + rnd(4,12), rnd(-10,10), rnd(40,80), 'rgba(120,255,200,0.06)', 360);
    }

    // draw particles
    particles.forEach(p=>{
      ctx.globalAlpha = Math.max(0, 1 - p.age / p.life);
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, 2 + (1 - p.age / p.life) * 4, 0, Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha = 1;

    // HUD title
    ctx.save();
    ctx.font = '700 16px Poppins, Inter, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillText('Neon Dodger', 18, 28);
    ctx.restore();
  }

  // game loop
  function loop(ts){
    raf = requestAnimationFrame(loop);
    update(ts || performance.now());
    draw();
  }

  // theme toggle
  themeBtn.addEventListener('click', ()=>{
    colorScheme = 1 - colorScheme;
    document.documentElement.style.setProperty('--neon1', colorScheme===0 ? '#00f0ff' : '#ff8ae0');
    document.documentElement.style.setProperty('--neon2', colorScheme===0 ? '#ff2ec8' : '#ffdf5b');
  });

  // fullscreen
  fsBtn.addEventListener('click', ()=>{
    const el = document.documentElement;
    if (!document.fullscreenElement) el.requestFullscreen?.();
    else document.exitFullscreen?.();
  });

  // pause / restart
  pauseBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', ()=>{ reset(); overlay.style.opacity = 1; overlay.style.pointerEvents='all'; startBtn.textContent = 'Start'; });

  // start button
  startBtn.addEventListener('click', ()=> start());

  // show/hide sound (simple oscillator for feedback)
  let soundOn = true;
  soundBtn.addEventListener('click', ()=>{ soundOn = !soundOn; soundBtn.textContent = 'Sound: ' + (soundOn ? 'On' : 'Off'); });

  // simple audio feedback using WebAudio
  const ctxAudio = window.AudioContext ? new AudioContext() : null;
  function playHit(){
    if (!soundOn || !ctxAudio) return;
    const o = ctxAudio.createOscillator();
    const g = ctxAudio.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(120, ctxAudio.currentTime);
    g.gain.setValueAtTime(0.0001, ctxAudio.currentTime);
    g.gain.exponentialRampToValueAtTime(0.12, ctxAudio.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctxAudio.currentTime + 0.3);
    o.connect(g); g.connect(ctxAudio.destination);
    o.start(); o.stop(ctxAudio.currentTime + 0.35);
  }

  // init sizes, draw once
  calcSize();
  reset();
  draw();

  // keyboard quick controls for start/pause
  window.addEventListener('keydown', e=>{
    if (e.key === ' ' && !running) { start(); return; }
    if (e.key === 'p') togglePause();
  });

})();
</script>
</body>
</html>